"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(home)/page",{

/***/ "(app-pages-browser)/./node_modules/@neodrag/react/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@neodrag/react/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDraggable: () => (/* binding */ useDraggable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar DEFAULT_DRAG_THRESHOLD = {\n  delay: 0,\n  distance: 3\n  /* DISTANCE */\n};\nfunction draggable(node, options = {}) {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = false,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    threshold = DEFAULT_DRAG_THRESHOLD,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = { x: 0, y: 0 },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let is_interacting = false;\n  let is_dragging = false;\n  let start_time = 0;\n  let meets_time_threshold = false;\n  let meets_distance_threshold = false;\n  let translate_x = 0, translate_y = 0;\n  let initial_x = 0, initial_y = 0;\n  let client_to_node_offsetX = 0, client_to_node_offsetY = 0;\n  let { x: x_offset, y: y_offset } = position ? { x: position?.x ?? 0, y: position?.y ?? 0 } : defaultPosition;\n  set_translate(x_offset, y_offset);\n  let can_move_in_x;\n  let can_move_in_y;\n  let body_original_user_select_val = \"\";\n  let computed_bounds;\n  let node_rect;\n  let drag_els;\n  let cancel_els;\n  let currently_dragged_el;\n  let is_controlled = !!position;\n  recomputeBounds = { ...DEFAULT_RECOMPUTE_BOUNDS, ...recomputeBounds };\n  threshold = { ...DEFAULT_DRAG_THRESHOLD, ...threshold ?? {} };\n  let active_pointers = /* @__PURE__ */ new Set();\n  function try_start_drag(event) {\n    if (is_interacting && !is_dragging && meets_distance_threshold && meets_time_threshold && currently_dragged_el) {\n      is_dragging = true;\n      fire_svelte_drag_start_event(event);\n      node_class_list.add(defaultClassDragging);\n      if (applyUserSelectHack) {\n        body_original_user_select_val = body_style.userSelect;\n        body_style.userSelect = \"none\";\n      }\n    }\n  }\n  function reset_state() {\n    is_dragging = false;\n    meets_time_threshold = false;\n    meets_distance_threshold = false;\n  }\n  const body_style = document.body.style;\n  const node_class_list = node.classList;\n  function set_translate(x_pos = translate_x, y_pos = translate_y) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+x_pos}px, ${+y_pos}px`;\n        return set_style(\n          node,\n          \"transform\",\n          gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`\n        );\n      }\n      return set_style(node, \"translate\", `${+x_pos}px ${+y_pos}px`);\n    }\n    const transform_called = transform({ offsetX: x_pos, offsetY: y_pos, rootNode: node });\n    if (is_string(transform_called)) {\n      set_style(node, \"transform\", transform_called);\n    }\n  }\n  function get_event_data(event) {\n    return {\n      offsetX: translate_x,\n      offsetY: translate_y,\n      rootNode: node,\n      currentNode: currently_dragged_el,\n      event\n    };\n  }\n  function call_event(eventName, fn, event) {\n    const data = get_event_data(event);\n    node.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    fn?.(data);\n  }\n  function fire_svelte_drag_start_event(event) {\n    call_event(\"neodrag:start\", onDragStart, event);\n  }\n  function fire_svelte_drag_end_event(event) {\n    call_event(\"neodrag:end\", onDragEnd, event);\n  }\n  function fire_svelte_drag_event(event) {\n    call_event(\"neodrag\", onDrag, event);\n  }\n  const listen = addEventListener;\n  const controller = new AbortController();\n  const event_options = { signal: controller.signal, capture: false };\n  set_style(node, \"touch-action\", \"none\");\n  listen(\n    \"pointerdown\",\n    (e) => {\n      if (disabled) return;\n      if (e.button === 2) return;\n      active_pointers.add(e.pointerId);\n      if (ignoreMultitouch && active_pointers.size > 1) return e.preventDefault();\n      if (recomputeBounds.dragStart) computed_bounds = compute_bound_rect(bounds, node);\n      if (is_string(handle) && is_string(cancel) && handle === cancel)\n        throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n      node_class_list.add(defaultClass);\n      drag_els = get_handle_els(handle, node);\n      cancel_els = get_cancel_elements(cancel, node);\n      can_move_in_x = /(both|x)/.test(axis);\n      can_move_in_y = /(both|y)/.test(axis);\n      if (cancel_element_contains(cancel_els, drag_els))\n        throw new Error(\n          \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n        );\n      const event_target = e.composedPath()[0];\n      if (drag_els.some((el) => el.contains(event_target) || el.shadowRoot?.contains(event_target)) && !cancel_element_contains(cancel_els, [event_target])) {\n        currently_dragged_el = drag_els.length === 1 ? node : drag_els.find((el) => el.contains(event_target));\n        is_interacting = true;\n        start_time = Date.now();\n        if (!threshold.delay) {\n          meets_time_threshold = true;\n        }\n      } else return;\n      node_rect = node.getBoundingClientRect();\n      const { clientX, clientY } = e;\n      const inverse_scale = calculate_inverse_scale();\n      if (can_move_in_x) initial_x = clientX - x_offset / inverse_scale;\n      if (can_move_in_y) initial_y = clientY - y_offset / inverse_scale;\n      if (computed_bounds) {\n        client_to_node_offsetX = clientX - node_rect.left;\n        client_to_node_offsetY = clientY - node_rect.top;\n      }\n    },\n    event_options\n  );\n  listen(\n    \"pointermove\",\n    (e) => {\n      if (!is_interacting || ignoreMultitouch && active_pointers.size > 1) return;\n      if (!is_dragging) {\n        if (!meets_time_threshold) {\n          const elapsed = Date.now() - start_time;\n          if (elapsed >= threshold.delay) {\n            meets_time_threshold = true;\n            try_start_drag(e);\n          }\n        }\n        if (!meets_distance_threshold) {\n          const delta_x = e.clientX - initial_x;\n          const delta_y = e.clientY - initial_y;\n          const distance = Math.sqrt(delta_x ** 2 + delta_y ** 2);\n          if (distance >= threshold.distance) {\n            meets_distance_threshold = true;\n            try_start_drag(e);\n          }\n        }\n        if (!is_dragging) return;\n      }\n      if (recomputeBounds.drag) computed_bounds = compute_bound_rect(bounds, node);\n      e.preventDefault();\n      node_rect = node.getBoundingClientRect();\n      let final_x = e.clientX, final_y = e.clientY;\n      const inverse_scale = calculate_inverse_scale();\n      if (computed_bounds) {\n        const virtual_client_bounds = {\n          left: computed_bounds.left + client_to_node_offsetX,\n          top: computed_bounds.top + client_to_node_offsetY,\n          right: computed_bounds.right + client_to_node_offsetX - node_rect.width,\n          bottom: computed_bounds.bottom + client_to_node_offsetY - node_rect.height\n        };\n        final_x = clamp(final_x, virtual_client_bounds.left, virtual_client_bounds.right);\n        final_y = clamp(final_y, virtual_client_bounds.top, virtual_client_bounds.bottom);\n      }\n      if (Array.isArray(grid)) {\n        let [x_snap, y_snap] = grid;\n        if (isNaN(+x_snap) || x_snap < 0)\n          throw new Error(\"1st argument of `grid` must be a valid positive number\");\n        if (isNaN(+y_snap) || y_snap < 0)\n          throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n        let delta_x = final_x - initial_x, delta_y = final_y - initial_y;\n        [delta_x, delta_y] = snap_to_grid(\n          [x_snap / inverse_scale, y_snap / inverse_scale],\n          delta_x,\n          delta_y\n        );\n        final_x = initial_x + delta_x;\n        final_y = initial_y + delta_y;\n      }\n      if (can_move_in_x) translate_x = Math.round((final_x - initial_x) * inverse_scale);\n      if (can_move_in_y) translate_y = Math.round((final_y - initial_y) * inverse_scale);\n      x_offset = translate_x;\n      y_offset = translate_y;\n      fire_svelte_drag_event(e);\n      set_translate();\n    },\n    event_options\n  );\n  listen(\n    \"pointerup\",\n    (e) => {\n      active_pointers.delete(e.pointerId);\n      if (!is_interacting) return;\n      if (is_dragging) {\n        listen(\"click\", (e2) => e2.stopPropagation(), {\n          once: true,\n          signal: controller.signal,\n          capture: true\n        });\n        if (recomputeBounds.dragEnd) computed_bounds = compute_bound_rect(bounds, node);\n        node_class_list.remove(defaultClassDragging);\n        node_class_list.add(defaultClassDragged);\n        if (applyUserSelectHack) body_style.userSelect = body_original_user_select_val;\n        fire_svelte_drag_end_event(e);\n        if (can_move_in_x) initial_x = translate_x;\n        if (can_move_in_y) initial_y = translate_y;\n      }\n      is_interacting = false;\n      reset_state();\n    },\n    event_options\n  );\n  function calculate_inverse_scale() {\n    let inverse_scale = node.offsetWidth / node_rect.width;\n    if (isNaN(inverse_scale)) inverse_scale = 1;\n    return inverse_scale;\n  }\n  return {\n    destroy: () => controller.abort(),\n    update: (options2) => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? false;\n      transform = options2.transform;\n      threshold = { ...DEFAULT_DRAG_THRESHOLD, ...options2.threshold ?? {} };\n      const dragged = node_class_list.contains(defaultClassDragged);\n      node_class_list.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      node_class_list.add(defaultClass);\n      if (dragged) node_class_list.add(defaultClassDragged);\n      if (is_controlled) {\n        x_offset = translate_x = options2.position?.x ?? translate_x;\n        y_offset = translate_y = options2.position?.y ?? translate_y;\n        set_translate();\n      }\n    }\n  };\n}\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar is_string = (val) => typeof val === \"string\";\nvar snap_to_grid = ([x_snap, y_snap], pending_x, pending_y) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pending_x, x_snap);\n  const y = calc(pending_y, y_snap);\n  return [x, y];\n};\nfunction get_handle_els(handle, node) {\n  if (!handle) return [node];\n  if (is_HTMLElement(handle)) return [handle];\n  if (Array.isArray(handle)) return handle;\n  const handle_els = node.querySelectorAll(handle);\n  if (handle_els === null)\n    throw new Error(\n      \"Selector passed for `handle` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(handle_els.values());\n}\nfunction get_cancel_elements(cancel, node) {\n  if (!cancel) return [];\n  if (is_HTMLElement(cancel)) return [cancel];\n  if (Array.isArray(cancel)) return cancel;\n  const cancel_els = node.querySelectorAll(cancel);\n  if (cancel_els === null)\n    throw new Error(\n      \"Selector passed for `cancel` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(cancel_els.values());\n}\nvar cancel_element_contains = (cancel_elements, drag_elements) => cancel_elements.some((cancelEl) => drag_elements.some((el) => cancelEl.contains(el)));\nfunction compute_bound_rect(bounds, rootNode) {\n  if (bounds === void 0) return;\n  if (is_HTMLElement(bounds)) return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n    const computed_right = window.innerWidth - right;\n    const computed_bottom = window.innerHeight - bottom;\n    return { top, right: computed_right, bottom: computed_bottom, left };\n  }\n  if (bounds === \"parent\") return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar set_style = (el, style, value) => el.style.setProperty(style, value);\nvar is_HTMLElement = (obj) => obj instanceof HTMLElement;\nfunction unwrap_handle_cancel(val) {\n  if (val == void 0 || typeof val === \"string\" || val instanceof HTMLElement) return val;\n  if (\"current\" in val) return val.current;\n  if (Array.isArray(val)) {\n    return val.map((v) => v instanceof HTMLElement ? v : v.current);\n  }\n}\nfunction useDraggable(nodeRef, options = {}) {\n  const update_ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const [isDragging, set_is_dragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [dragState, set_drag_state] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  let { onDragStart, onDrag, onDragEnd, handle, cancel } = options;\n  let new_handle = unwrap_handle_cancel(handle);\n  let new_cancel = unwrap_handle_cancel(cancel);\n  function call_event(arg, cb) {\n    set_drag_state(arg);\n    cb?.(arg);\n  }\n  function custom_on_drag_start(arg) {\n    set_is_dragging(true);\n    call_event(arg, onDragStart);\n  }\n  function custom_on_drag(arg) {\n    call_event(arg, onDrag);\n  }\n  function custom_on_drag_end(arg) {\n    set_is_dragging(false);\n    call_event(arg, onDragEnd);\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (typeof window === \"undefined\") return;\n    const node = nodeRef.current;\n    if (!node) return;\n    ({ onDragStart, onDrag, onDragEnd } = options);\n    const { update, destroy } = draggable(node, {\n      ...options,\n      handle: new_handle,\n      cancel: new_cancel,\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n    update_ref.current = update;\n    return destroy;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    update_ref.current?.({\n      ...options,\n      handle: unwrap_handle_cancel(handle),\n      cancel: unwrap_handle_cancel(cancel),\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n  }, [options]);\n  return { isDragging, dragState };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbmVvZHJhZy9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUEyQixlQUFlLDJDQUEyQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxNQUFNLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU8scUJBQXFCLE9BQU87QUFDOUU7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLEtBQUssT0FBTztBQUNoRTtBQUNBLHlDQUF5QyxnREFBZ0Q7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUJBQXFCLDZDQUFNO0FBQzNCLHdDQUF3QywrQ0FBUTtBQUNoRCxzQ0FBc0MsK0NBQVE7QUFDOUMsUUFBUSxpREFBaUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlDQUFpQztBQUN4QyxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILFdBQVc7QUFDWDs7QUFFd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9nb25ld2l0aG1pbmQvRG9jdW1lbnRzL0dpdEh1Yi9jcmVhdHVyZS1kZXNpZ24vbm9kZV9tb2R1bGVzL0BuZW9kcmFnL3JlYWN0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyAuLi9jb3JlL2Rpc3QvaW5kZXguanNcbnZhciBERUZBVUxUX1JFQ09NUFVURV9CT1VORFMgPSB7XG4gIGRyYWdTdGFydDogdHJ1ZVxufTtcbnZhciBERUZBVUxUX0RSQUdfVEhSRVNIT0xEID0ge1xuICBkZWxheTogMCxcbiAgZGlzdGFuY2U6IDNcbiAgLyogRElTVEFOQ0UgKi9cbn07XG5mdW5jdGlvbiBkcmFnZ2FibGUobm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7XG4gICAgYm91bmRzLFxuICAgIGF4aXMgPSBcImJvdGhcIixcbiAgICBncHVBY2NlbGVyYXRpb24gPSB0cnVlLFxuICAgIGxlZ2FjeVRyYW5zbGF0ZSA9IGZhbHNlLFxuICAgIHRyYW5zZm9ybSxcbiAgICBhcHBseVVzZXJTZWxlY3RIYWNrID0gdHJ1ZSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGlnbm9yZU11bHRpdG91Y2ggPSBmYWxzZSxcbiAgICByZWNvbXB1dGVCb3VuZHMgPSBERUZBVUxUX1JFQ09NUFVURV9CT1VORFMsXG4gICAgZ3JpZCxcbiAgICB0aHJlc2hvbGQgPSBERUZBVUxUX0RSQUdfVEhSRVNIT0xELFxuICAgIHBvc2l0aW9uLFxuICAgIGNhbmNlbCxcbiAgICBoYW5kbGUsXG4gICAgZGVmYXVsdENsYXNzID0gXCJuZW9kcmFnXCIsXG4gICAgZGVmYXVsdENsYXNzRHJhZ2dpbmcgPSBcIm5lb2RyYWctZHJhZ2dpbmdcIixcbiAgICBkZWZhdWx0Q2xhc3NEcmFnZ2VkID0gXCJuZW9kcmFnLWRyYWdnZWRcIixcbiAgICBkZWZhdWx0UG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSxcbiAgICBvbkRyYWdTdGFydCxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnRW5kXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgaXNfaW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgbGV0IGlzX2RyYWdnaW5nID0gZmFsc2U7XG4gIGxldCBzdGFydF90aW1lID0gMDtcbiAgbGV0IG1lZXRzX3RpbWVfdGhyZXNob2xkID0gZmFsc2U7XG4gIGxldCBtZWV0c19kaXN0YW5jZV90aHJlc2hvbGQgPSBmYWxzZTtcbiAgbGV0IHRyYW5zbGF0ZV94ID0gMCwgdHJhbnNsYXRlX3kgPSAwO1xuICBsZXQgaW5pdGlhbF94ID0gMCwgaW5pdGlhbF95ID0gMDtcbiAgbGV0IGNsaWVudF90b19ub2RlX29mZnNldFggPSAwLCBjbGllbnRfdG9fbm9kZV9vZmZzZXRZID0gMDtcbiAgbGV0IHsgeDogeF9vZmZzZXQsIHk6IHlfb2Zmc2V0IH0gPSBwb3NpdGlvbiA/IHsgeDogcG9zaXRpb24/LnggPz8gMCwgeTogcG9zaXRpb24/LnkgPz8gMCB9IDogZGVmYXVsdFBvc2l0aW9uO1xuICBzZXRfdHJhbnNsYXRlKHhfb2Zmc2V0LCB5X29mZnNldCk7XG4gIGxldCBjYW5fbW92ZV9pbl94O1xuICBsZXQgY2FuX21vdmVfaW5feTtcbiAgbGV0IGJvZHlfb3JpZ2luYWxfdXNlcl9zZWxlY3RfdmFsID0gXCJcIjtcbiAgbGV0IGNvbXB1dGVkX2JvdW5kcztcbiAgbGV0IG5vZGVfcmVjdDtcbiAgbGV0IGRyYWdfZWxzO1xuICBsZXQgY2FuY2VsX2VscztcbiAgbGV0IGN1cnJlbnRseV9kcmFnZ2VkX2VsO1xuICBsZXQgaXNfY29udHJvbGxlZCA9ICEhcG9zaXRpb247XG4gIHJlY29tcHV0ZUJvdW5kcyA9IHsgLi4uREVGQVVMVF9SRUNPTVBVVEVfQk9VTkRTLCAuLi5yZWNvbXB1dGVCb3VuZHMgfTtcbiAgdGhyZXNob2xkID0geyAuLi5ERUZBVUxUX0RSQUdfVEhSRVNIT0xELCAuLi50aHJlc2hvbGQgPz8ge30gfTtcbiAgbGV0IGFjdGl2ZV9wb2ludGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIHRyeV9zdGFydF9kcmFnKGV2ZW50KSB7XG4gICAgaWYgKGlzX2ludGVyYWN0aW5nICYmICFpc19kcmFnZ2luZyAmJiBtZWV0c19kaXN0YW5jZV90aHJlc2hvbGQgJiYgbWVldHNfdGltZV90aHJlc2hvbGQgJiYgY3VycmVudGx5X2RyYWdnZWRfZWwpIHtcbiAgICAgIGlzX2RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIGZpcmVfc3ZlbHRlX2RyYWdfc3RhcnRfZXZlbnQoZXZlbnQpO1xuICAgICAgbm9kZV9jbGFzc19saXN0LmFkZChkZWZhdWx0Q2xhc3NEcmFnZ2luZyk7XG4gICAgICBpZiAoYXBwbHlVc2VyU2VsZWN0SGFjaykge1xuICAgICAgICBib2R5X29yaWdpbmFsX3VzZXJfc2VsZWN0X3ZhbCA9IGJvZHlfc3R5bGUudXNlclNlbGVjdDtcbiAgICAgICAgYm9keV9zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc2V0X3N0YXRlKCkge1xuICAgIGlzX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgbWVldHNfdGltZV90aHJlc2hvbGQgPSBmYWxzZTtcbiAgICBtZWV0c19kaXN0YW5jZV90aHJlc2hvbGQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBib2R5X3N0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgY29uc3Qgbm9kZV9jbGFzc19saXN0ID0gbm9kZS5jbGFzc0xpc3Q7XG4gIGZ1bmN0aW9uIHNldF90cmFuc2xhdGUoeF9wb3MgPSB0cmFuc2xhdGVfeCwgeV9wb3MgPSB0cmFuc2xhdGVfeSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICBpZiAobGVnYWN5VHJhbnNsYXRlKSB7XG4gICAgICAgIGxldCBjb21tb24gPSBgJHsreF9wb3N9cHgsICR7K3lfcG9zfXB4YDtcbiAgICAgICAgcmV0dXJuIHNldF9zdHlsZShcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgZ3B1QWNjZWxlcmF0aW9uID8gYHRyYW5zbGF0ZTNkKCR7Y29tbW9ufSwgMClgIDogYHRyYW5zbGF0ZSgke2NvbW1vbn0pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldF9zdHlsZShub2RlLCBcInRyYW5zbGF0ZVwiLCBgJHsreF9wb3N9cHggJHsreV9wb3N9cHhgKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtX2NhbGxlZCA9IHRyYW5zZm9ybSh7IG9mZnNldFg6IHhfcG9zLCBvZmZzZXRZOiB5X3Bvcywgcm9vdE5vZGU6IG5vZGUgfSk7XG4gICAgaWYgKGlzX3N0cmluZyh0cmFuc2Zvcm1fY2FsbGVkKSkge1xuICAgICAgc2V0X3N0eWxlKG5vZGUsIFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybV9jYWxsZWQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRfZXZlbnRfZGF0YShldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYOiB0cmFuc2xhdGVfeCxcbiAgICAgIG9mZnNldFk6IHRyYW5zbGF0ZV95LFxuICAgICAgcm9vdE5vZGU6IG5vZGUsXG4gICAgICBjdXJyZW50Tm9kZTogY3VycmVudGx5X2RyYWdnZWRfZWwsXG4gICAgICBldmVudFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FsbF9ldmVudChldmVudE5hbWUsIGZuLCBldmVudCkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRfZXZlbnRfZGF0YShldmVudCk7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsOiBkYXRhIH0pKTtcbiAgICBmbj8uKGRhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIGZpcmVfc3ZlbHRlX2RyYWdfc3RhcnRfZXZlbnQoZXZlbnQpIHtcbiAgICBjYWxsX2V2ZW50KFwibmVvZHJhZzpzdGFydFwiLCBvbkRyYWdTdGFydCwgZXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGZpcmVfc3ZlbHRlX2RyYWdfZW5kX2V2ZW50KGV2ZW50KSB7XG4gICAgY2FsbF9ldmVudChcIm5lb2RyYWc6ZW5kXCIsIG9uRHJhZ0VuZCwgZXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGZpcmVfc3ZlbHRlX2RyYWdfZXZlbnQoZXZlbnQpIHtcbiAgICBjYWxsX2V2ZW50KFwibmVvZHJhZ1wiLCBvbkRyYWcsIGV2ZW50KTtcbiAgfVxuICBjb25zdCBsaXN0ZW4gPSBhZGRFdmVudExpc3RlbmVyO1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdCBldmVudF9vcHRpb25zID0geyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLCBjYXB0dXJlOiBmYWxzZSB9O1xuICBzZXRfc3R5bGUobm9kZSwgXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICBsaXN0ZW4oXG4gICAgXCJwb2ludGVyZG93blwiLFxuICAgIChlKSA9PiB7XG4gICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMikgcmV0dXJuO1xuICAgICAgYWN0aXZlX3BvaW50ZXJzLmFkZChlLnBvaW50ZXJJZCk7XG4gICAgICBpZiAoaWdub3JlTXVsdGl0b3VjaCAmJiBhY3RpdmVfcG9pbnRlcnMuc2l6ZSA+IDEpIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAocmVjb21wdXRlQm91bmRzLmRyYWdTdGFydCkgY29tcHV0ZWRfYm91bmRzID0gY29tcHV0ZV9ib3VuZF9yZWN0KGJvdW5kcywgbm9kZSk7XG4gICAgICBpZiAoaXNfc3RyaW5nKGhhbmRsZSkgJiYgaXNfc3RyaW5nKGNhbmNlbCkgJiYgaGFuZGxlID09PSBjYW5jZWwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBoYW5kbGVgIHNlbGVjdG9yIGNhbid0IGJlIHNhbWUgYXMgYGNhbmNlbGAgc2VsZWN0b3JcIik7XG4gICAgICBub2RlX2NsYXNzX2xpc3QuYWRkKGRlZmF1bHRDbGFzcyk7XG4gICAgICBkcmFnX2VscyA9IGdldF9oYW5kbGVfZWxzKGhhbmRsZSwgbm9kZSk7XG4gICAgICBjYW5jZWxfZWxzID0gZ2V0X2NhbmNlbF9lbGVtZW50cyhjYW5jZWwsIG5vZGUpO1xuICAgICAgY2FuX21vdmVfaW5feCA9IC8oYm90aHx4KS8udGVzdChheGlzKTtcbiAgICAgIGNhbl9tb3ZlX2luX3kgPSAvKGJvdGh8eSkvLnRlc3QoYXhpcyk7XG4gICAgICBpZiAoY2FuY2VsX2VsZW1lbnRfY29udGFpbnMoY2FuY2VsX2VscywgZHJhZ19lbHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJFbGVtZW50IGJlaW5nIGRyYWdnZWQgY2FuJ3QgYmUgYSBjaGlsZCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCBgY2FuY2VsYCBpcyBhcHBsaWVkXCJcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IGV2ZW50X3RhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBpZiAoZHJhZ19lbHMuc29tZSgoZWwpID0+IGVsLmNvbnRhaW5zKGV2ZW50X3RhcmdldCkgfHwgZWwuc2hhZG93Um9vdD8uY29udGFpbnMoZXZlbnRfdGFyZ2V0KSkgJiYgIWNhbmNlbF9lbGVtZW50X2NvbnRhaW5zKGNhbmNlbF9lbHMsIFtldmVudF90YXJnZXRdKSkge1xuICAgICAgICBjdXJyZW50bHlfZHJhZ2dlZF9lbCA9IGRyYWdfZWxzLmxlbmd0aCA9PT0gMSA/IG5vZGUgOiBkcmFnX2Vscy5maW5kKChlbCkgPT4gZWwuY29udGFpbnMoZXZlbnRfdGFyZ2V0KSk7XG4gICAgICAgIGlzX2ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICghdGhyZXNob2xkLmRlbGF5KSB7XG4gICAgICAgICAgbWVldHNfdGltZV90aHJlc2hvbGQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgcmV0dXJuO1xuICAgICAgbm9kZV9yZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IGludmVyc2Vfc2NhbGUgPSBjYWxjdWxhdGVfaW52ZXJzZV9zY2FsZSgpO1xuICAgICAgaWYgKGNhbl9tb3ZlX2luX3gpIGluaXRpYWxfeCA9IGNsaWVudFggLSB4X29mZnNldCAvIGludmVyc2Vfc2NhbGU7XG4gICAgICBpZiAoY2FuX21vdmVfaW5feSkgaW5pdGlhbF95ID0gY2xpZW50WSAtIHlfb2Zmc2V0IC8gaW52ZXJzZV9zY2FsZTtcbiAgICAgIGlmIChjb21wdXRlZF9ib3VuZHMpIHtcbiAgICAgICAgY2xpZW50X3RvX25vZGVfb2Zmc2V0WCA9IGNsaWVudFggLSBub2RlX3JlY3QubGVmdDtcbiAgICAgICAgY2xpZW50X3RvX25vZGVfb2Zmc2V0WSA9IGNsaWVudFkgLSBub2RlX3JlY3QudG9wO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRfb3B0aW9uc1xuICApO1xuICBsaXN0ZW4oXG4gICAgXCJwb2ludGVybW92ZVwiLFxuICAgIChlKSA9PiB7XG4gICAgICBpZiAoIWlzX2ludGVyYWN0aW5nIHx8IGlnbm9yZU11bHRpdG91Y2ggJiYgYWN0aXZlX3BvaW50ZXJzLnNpemUgPiAxKSByZXR1cm47XG4gICAgICBpZiAoIWlzX2RyYWdnaW5nKSB7XG4gICAgICAgIGlmICghbWVldHNfdGltZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0X3RpbWU7XG4gICAgICAgICAgaWYgKGVsYXBzZWQgPj0gdGhyZXNob2xkLmRlbGF5KSB7XG4gICAgICAgICAgICBtZWV0c190aW1lX3RocmVzaG9sZCA9IHRydWU7XG4gICAgICAgICAgICB0cnlfc3RhcnRfZHJhZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZWV0c19kaXN0YW5jZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICBjb25zdCBkZWx0YV94ID0gZS5jbGllbnRYIC0gaW5pdGlhbF94O1xuICAgICAgICAgIGNvbnN0IGRlbHRhX3kgPSBlLmNsaWVudFkgLSBpbml0aWFsX3k7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGVsdGFfeCAqKiAyICsgZGVsdGFfeSAqKiAyKTtcbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPj0gdGhyZXNob2xkLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBtZWV0c19kaXN0YW5jZV90aHJlc2hvbGQgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5X3N0YXJ0X2RyYWcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNfZHJhZ2dpbmcpIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWNvbXB1dGVCb3VuZHMuZHJhZykgY29tcHV0ZWRfYm91bmRzID0gY29tcHV0ZV9ib3VuZF9yZWN0KGJvdW5kcywgbm9kZSk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBub2RlX3JlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IGZpbmFsX3ggPSBlLmNsaWVudFgsIGZpbmFsX3kgPSBlLmNsaWVudFk7XG4gICAgICBjb25zdCBpbnZlcnNlX3NjYWxlID0gY2FsY3VsYXRlX2ludmVyc2Vfc2NhbGUoKTtcbiAgICAgIGlmIChjb21wdXRlZF9ib3VuZHMpIHtcbiAgICAgICAgY29uc3QgdmlydHVhbF9jbGllbnRfYm91bmRzID0ge1xuICAgICAgICAgIGxlZnQ6IGNvbXB1dGVkX2JvdW5kcy5sZWZ0ICsgY2xpZW50X3RvX25vZGVfb2Zmc2V0WCxcbiAgICAgICAgICB0b3A6IGNvbXB1dGVkX2JvdW5kcy50b3AgKyBjbGllbnRfdG9fbm9kZV9vZmZzZXRZLFxuICAgICAgICAgIHJpZ2h0OiBjb21wdXRlZF9ib3VuZHMucmlnaHQgKyBjbGllbnRfdG9fbm9kZV9vZmZzZXRYIC0gbm9kZV9yZWN0LndpZHRoLFxuICAgICAgICAgIGJvdHRvbTogY29tcHV0ZWRfYm91bmRzLmJvdHRvbSArIGNsaWVudF90b19ub2RlX29mZnNldFkgLSBub2RlX3JlY3QuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGZpbmFsX3ggPSBjbGFtcChmaW5hbF94LCB2aXJ0dWFsX2NsaWVudF9ib3VuZHMubGVmdCwgdmlydHVhbF9jbGllbnRfYm91bmRzLnJpZ2h0KTtcbiAgICAgICAgZmluYWxfeSA9IGNsYW1wKGZpbmFsX3ksIHZpcnR1YWxfY2xpZW50X2JvdW5kcy50b3AsIHZpcnR1YWxfY2xpZW50X2JvdW5kcy5ib3R0b20pO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ3JpZCkpIHtcbiAgICAgICAgbGV0IFt4X3NuYXAsIHlfc25hcF0gPSBncmlkO1xuICAgICAgICBpZiAoaXNOYU4oK3hfc25hcCkgfHwgeF9zbmFwIDwgMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIxc3QgYXJndW1lbnQgb2YgYGdyaWRgIG11c3QgYmUgYSB2YWxpZCBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIGlmIChpc05hTigreV9zbmFwKSB8fCB5X3NuYXAgPCAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIjJuZCBhcmd1bWVudCBvZiBgZ3JpZGAgbXVzdCBiZSBhIHZhbGlkIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgbGV0IGRlbHRhX3ggPSBmaW5hbF94IC0gaW5pdGlhbF94LCBkZWx0YV95ID0gZmluYWxfeSAtIGluaXRpYWxfeTtcbiAgICAgICAgW2RlbHRhX3gsIGRlbHRhX3ldID0gc25hcF90b19ncmlkKFxuICAgICAgICAgIFt4X3NuYXAgLyBpbnZlcnNlX3NjYWxlLCB5X3NuYXAgLyBpbnZlcnNlX3NjYWxlXSxcbiAgICAgICAgICBkZWx0YV94LFxuICAgICAgICAgIGRlbHRhX3lcbiAgICAgICAgKTtcbiAgICAgICAgZmluYWxfeCA9IGluaXRpYWxfeCArIGRlbHRhX3g7XG4gICAgICAgIGZpbmFsX3kgPSBpbml0aWFsX3kgKyBkZWx0YV95O1xuICAgICAgfVxuICAgICAgaWYgKGNhbl9tb3ZlX2luX3gpIHRyYW5zbGF0ZV94ID0gTWF0aC5yb3VuZCgoZmluYWxfeCAtIGluaXRpYWxfeCkgKiBpbnZlcnNlX3NjYWxlKTtcbiAgICAgIGlmIChjYW5fbW92ZV9pbl95KSB0cmFuc2xhdGVfeSA9IE1hdGgucm91bmQoKGZpbmFsX3kgLSBpbml0aWFsX3kpICogaW52ZXJzZV9zY2FsZSk7XG4gICAgICB4X29mZnNldCA9IHRyYW5zbGF0ZV94O1xuICAgICAgeV9vZmZzZXQgPSB0cmFuc2xhdGVfeTtcbiAgICAgIGZpcmVfc3ZlbHRlX2RyYWdfZXZlbnQoZSk7XG4gICAgICBzZXRfdHJhbnNsYXRlKCk7XG4gICAgfSxcbiAgICBldmVudF9vcHRpb25zXG4gICk7XG4gIGxpc3RlbihcbiAgICBcInBvaW50ZXJ1cFwiLFxuICAgIChlKSA9PiB7XG4gICAgICBhY3RpdmVfcG9pbnRlcnMuZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgIGlmICghaXNfaW50ZXJhY3RpbmcpIHJldHVybjtcbiAgICAgIGlmIChpc19kcmFnZ2luZykge1xuICAgICAgICBsaXN0ZW4oXCJjbGlja1wiLCAoZTIpID0+IGUyLnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWNvbXB1dGVCb3VuZHMuZHJhZ0VuZCkgY29tcHV0ZWRfYm91bmRzID0gY29tcHV0ZV9ib3VuZF9yZWN0KGJvdW5kcywgbm9kZSk7XG4gICAgICAgIG5vZGVfY2xhc3NfbGlzdC5yZW1vdmUoZGVmYXVsdENsYXNzRHJhZ2dpbmcpO1xuICAgICAgICBub2RlX2NsYXNzX2xpc3QuYWRkKGRlZmF1bHRDbGFzc0RyYWdnZWQpO1xuICAgICAgICBpZiAoYXBwbHlVc2VyU2VsZWN0SGFjaykgYm9keV9zdHlsZS51c2VyU2VsZWN0ID0gYm9keV9vcmlnaW5hbF91c2VyX3NlbGVjdF92YWw7XG4gICAgICAgIGZpcmVfc3ZlbHRlX2RyYWdfZW5kX2V2ZW50KGUpO1xuICAgICAgICBpZiAoY2FuX21vdmVfaW5feCkgaW5pdGlhbF94ID0gdHJhbnNsYXRlX3g7XG4gICAgICAgIGlmIChjYW5fbW92ZV9pbl95KSBpbml0aWFsX3kgPSB0cmFuc2xhdGVfeTtcbiAgICAgIH1cbiAgICAgIGlzX2ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICByZXNldF9zdGF0ZSgpO1xuICAgIH0sXG4gICAgZXZlbnRfb3B0aW9uc1xuICApO1xuICBmdW5jdGlvbiBjYWxjdWxhdGVfaW52ZXJzZV9zY2FsZSgpIHtcbiAgICBsZXQgaW52ZXJzZV9zY2FsZSA9IG5vZGUub2Zmc2V0V2lkdGggLyBub2RlX3JlY3Qud2lkdGg7XG4gICAgaWYgKGlzTmFOKGludmVyc2Vfc2NhbGUpKSBpbnZlcnNlX3NjYWxlID0gMTtcbiAgICByZXR1cm4gaW52ZXJzZV9zY2FsZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICB1cGRhdGU6IChvcHRpb25zMikgPT4ge1xuICAgICAgYXhpcyA9IG9wdGlvbnMyLmF4aXMgfHwgXCJib3RoXCI7XG4gICAgICBkaXNhYmxlZCA9IG9wdGlvbnMyLmRpc2FibGVkID8/IGZhbHNlO1xuICAgICAgaWdub3JlTXVsdGl0b3VjaCA9IG9wdGlvbnMyLmlnbm9yZU11bHRpdG91Y2ggPz8gZmFsc2U7XG4gICAgICBoYW5kbGUgPSBvcHRpb25zMi5oYW5kbGU7XG4gICAgICBib3VuZHMgPSBvcHRpb25zMi5ib3VuZHM7XG4gICAgICByZWNvbXB1dGVCb3VuZHMgPSBvcHRpb25zMi5yZWNvbXB1dGVCb3VuZHMgPz8gREVGQVVMVF9SRUNPTVBVVEVfQk9VTkRTO1xuICAgICAgY2FuY2VsID0gb3B0aW9uczIuY2FuY2VsO1xuICAgICAgYXBwbHlVc2VyU2VsZWN0SGFjayA9IG9wdGlvbnMyLmFwcGx5VXNlclNlbGVjdEhhY2sgPz8gdHJ1ZTtcbiAgICAgIGdyaWQgPSBvcHRpb25zMi5ncmlkO1xuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gb3B0aW9uczIuZ3B1QWNjZWxlcmF0aW9uID8/IHRydWU7XG4gICAgICBsZWdhY3lUcmFuc2xhdGUgPSBvcHRpb25zMi5sZWdhY3lUcmFuc2xhdGUgPz8gZmFsc2U7XG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zMi50cmFuc2Zvcm07XG4gICAgICB0aHJlc2hvbGQgPSB7IC4uLkRFRkFVTFRfRFJBR19USFJFU0hPTEQsIC4uLm9wdGlvbnMyLnRocmVzaG9sZCA/PyB7fSB9O1xuICAgICAgY29uc3QgZHJhZ2dlZCA9IG5vZGVfY2xhc3NfbGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NEcmFnZ2VkKTtcbiAgICAgIG5vZGVfY2xhc3NfbGlzdC5yZW1vdmUoZGVmYXVsdENsYXNzLCBkZWZhdWx0Q2xhc3NEcmFnZ2VkKTtcbiAgICAgIGRlZmF1bHRDbGFzcyA9IG9wdGlvbnMyLmRlZmF1bHRDbGFzcyA/PyBcIm5lb2RyYWdcIjtcbiAgICAgIGRlZmF1bHRDbGFzc0RyYWdnaW5nID0gb3B0aW9uczIuZGVmYXVsdENsYXNzRHJhZ2dpbmcgPz8gXCJuZW9kcmFnLWRyYWdnaW5nXCI7XG4gICAgICBkZWZhdWx0Q2xhc3NEcmFnZ2VkID0gb3B0aW9uczIuZGVmYXVsdENsYXNzRHJhZ2dlZCA/PyBcIm5lb2RyYWctZHJhZ2dlZFwiO1xuICAgICAgbm9kZV9jbGFzc19saXN0LmFkZChkZWZhdWx0Q2xhc3MpO1xuICAgICAgaWYgKGRyYWdnZWQpIG5vZGVfY2xhc3NfbGlzdC5hZGQoZGVmYXVsdENsYXNzRHJhZ2dlZCk7XG4gICAgICBpZiAoaXNfY29udHJvbGxlZCkge1xuICAgICAgICB4X29mZnNldCA9IHRyYW5zbGF0ZV94ID0gb3B0aW9uczIucG9zaXRpb24/LnggPz8gdHJhbnNsYXRlX3g7XG4gICAgICAgIHlfb2Zmc2V0ID0gdHJhbnNsYXRlX3kgPSBvcHRpb25zMi5wb3NpdGlvbj8ueSA/PyB0cmFuc2xhdGVfeTtcbiAgICAgICAgc2V0X3RyYW5zbGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBjbGFtcCA9ICh2YWwsIG1pbiwgbWF4KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG52YXIgaXNfc3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbnZhciBzbmFwX3RvX2dyaWQgPSAoW3hfc25hcCwgeV9zbmFwXSwgcGVuZGluZ194LCBwZW5kaW5nX3kpID0+IHtcbiAgY29uc3QgY2FsYyA9ICh2YWwsIHNuYXApID0+IHNuYXAgPT09IDAgPyAwIDogTWF0aC5jZWlsKHZhbCAvIHNuYXApICogc25hcDtcbiAgY29uc3QgeCA9IGNhbGMocGVuZGluZ194LCB4X3NuYXApO1xuICBjb25zdCB5ID0gY2FsYyhwZW5kaW5nX3ksIHlfc25hcCk7XG4gIHJldHVybiBbeCwgeV07XG59O1xuZnVuY3Rpb24gZ2V0X2hhbmRsZV9lbHMoaGFuZGxlLCBub2RlKSB7XG4gIGlmICghaGFuZGxlKSByZXR1cm4gW25vZGVdO1xuICBpZiAoaXNfSFRNTEVsZW1lbnQoaGFuZGxlKSkgcmV0dXJuIFtoYW5kbGVdO1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGUpKSByZXR1cm4gaGFuZGxlO1xuICBjb25zdCBoYW5kbGVfZWxzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKGhhbmRsZSk7XG4gIGlmIChoYW5kbGVfZWxzID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiU2VsZWN0b3IgcGFzc2VkIGZvciBgaGFuZGxlYCBvcHRpb24gc2hvdWxkIGJlIGNoaWxkIG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBhY3Rpb24gaXMgYXBwbGllZFwiXG4gICAgKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oaGFuZGxlX2Vscy52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiBnZXRfY2FuY2VsX2VsZW1lbnRzKGNhbmNlbCwgbm9kZSkge1xuICBpZiAoIWNhbmNlbCkgcmV0dXJuIFtdO1xuICBpZiAoaXNfSFRNTEVsZW1lbnQoY2FuY2VsKSkgcmV0dXJuIFtjYW5jZWxdO1xuICBpZiAoQXJyYXkuaXNBcnJheShjYW5jZWwpKSByZXR1cm4gY2FuY2VsO1xuICBjb25zdCBjYW5jZWxfZWxzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKGNhbmNlbCk7XG4gIGlmIChjYW5jZWxfZWxzID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiU2VsZWN0b3IgcGFzc2VkIGZvciBgY2FuY2VsYCBvcHRpb24gc2hvdWxkIGJlIGNoaWxkIG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBhY3Rpb24gaXMgYXBwbGllZFwiXG4gICAgKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oY2FuY2VsX2Vscy52YWx1ZXMoKSk7XG59XG52YXIgY2FuY2VsX2VsZW1lbnRfY29udGFpbnMgPSAoY2FuY2VsX2VsZW1lbnRzLCBkcmFnX2VsZW1lbnRzKSA9PiBjYW5jZWxfZWxlbWVudHMuc29tZSgoY2FuY2VsRWwpID0+IGRyYWdfZWxlbWVudHMuc29tZSgoZWwpID0+IGNhbmNlbEVsLmNvbnRhaW5zKGVsKSkpO1xuZnVuY3Rpb24gY29tcHV0ZV9ib3VuZF9yZWN0KGJvdW5kcywgcm9vdE5vZGUpIHtcbiAgaWYgKGJvdW5kcyA9PT0gdm9pZCAwKSByZXR1cm47XG4gIGlmIChpc19IVE1MRWxlbWVudChib3VuZHMpKSByZXR1cm4gYm91bmRzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAodHlwZW9mIGJvdW5kcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHsgdG9wID0gMCwgbGVmdCA9IDAsIHJpZ2h0ID0gMCwgYm90dG9tID0gMCB9ID0gYm91bmRzO1xuICAgIGNvbnN0IGNvbXB1dGVkX3JpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSByaWdodDtcbiAgICBjb25zdCBjb21wdXRlZF9ib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3R0b207XG4gICAgcmV0dXJuIHsgdG9wLCByaWdodDogY29tcHV0ZWRfcmlnaHQsIGJvdHRvbTogY29tcHV0ZWRfYm90dG9tLCBsZWZ0IH07XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gXCJwYXJlbnRcIikgcmV0dXJuIHJvb3ROb2RlLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJvdW5kcyk7XG4gIGlmIChub2RlID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzZWxlY3RvciBwcm92aWRlZCBmb3IgYm91bmQgZG9lc24ndCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlwiKTtcbiAgcmV0dXJuIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG52YXIgc2V0X3N0eWxlID0gKGVsLCBzdHlsZSwgdmFsdWUpID0+IGVsLnN0eWxlLnNldFByb3BlcnR5KHN0eWxlLCB2YWx1ZSk7XG52YXIgaXNfSFRNTEVsZW1lbnQgPSAob2JqKSA9PiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbmZ1bmN0aW9uIHVud3JhcF9oYW5kbGVfY2FuY2VsKHZhbCkge1xuICBpZiAodmFsID09IHZvaWQgMCB8fCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHZhbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSByZXR1cm4gdmFsO1xuICBpZiAoXCJjdXJyZW50XCIgaW4gdmFsKSByZXR1cm4gdmFsLmN1cnJlbnQ7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLm1hcCgodikgPT4gdiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gdiA6IHYuY3VycmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZURyYWdnYWJsZShub2RlUmVmLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgdXBkYXRlX3JlZiA9IHVzZVJlZigpO1xuICBjb25zdCBbaXNEcmFnZ2luZywgc2V0X2lzX2RyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2RyYWdTdGF0ZSwgc2V0X2RyYWdfc3RhdGVdID0gdXNlU3RhdGUoKTtcbiAgbGV0IHsgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnRW5kLCBoYW5kbGUsIGNhbmNlbCB9ID0gb3B0aW9ucztcbiAgbGV0IG5ld19oYW5kbGUgPSB1bndyYXBfaGFuZGxlX2NhbmNlbChoYW5kbGUpO1xuICBsZXQgbmV3X2NhbmNlbCA9IHVud3JhcF9oYW5kbGVfY2FuY2VsKGNhbmNlbCk7XG4gIGZ1bmN0aW9uIGNhbGxfZXZlbnQoYXJnLCBjYikge1xuICAgIHNldF9kcmFnX3N0YXRlKGFyZyk7XG4gICAgY2I/LihhcmcpO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbV9vbl9kcmFnX3N0YXJ0KGFyZykge1xuICAgIHNldF9pc19kcmFnZ2luZyh0cnVlKTtcbiAgICBjYWxsX2V2ZW50KGFyZywgb25EcmFnU3RhcnQpO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbV9vbl9kcmFnKGFyZykge1xuICAgIGNhbGxfZXZlbnQoYXJnLCBvbkRyYWcpO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbV9vbl9kcmFnX2VuZChhcmcpIHtcbiAgICBzZXRfaXNfZHJhZ2dpbmcoZmFsc2UpO1xuICAgIGNhbGxfZXZlbnQoYXJnLCBvbkRyYWdFbmQpO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBjb25zdCBub2RlID0gbm9kZVJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICh7IG9uRHJhZ1N0YXJ0LCBvbkRyYWcsIG9uRHJhZ0VuZCB9ID0gb3B0aW9ucyk7XG4gICAgY29uc3QgeyB1cGRhdGUsIGRlc3Ryb3kgfSA9IGRyYWdnYWJsZShub2RlLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGFuZGxlOiBuZXdfaGFuZGxlLFxuICAgICAgY2FuY2VsOiBuZXdfY2FuY2VsLFxuICAgICAgb25EcmFnU3RhcnQ6IGN1c3RvbV9vbl9kcmFnX3N0YXJ0LFxuICAgICAgb25EcmFnOiBjdXN0b21fb25fZHJhZyxcbiAgICAgIG9uRHJhZ0VuZDogY3VzdG9tX29uX2RyYWdfZW5kXG4gICAgfSk7XG4gICAgdXBkYXRlX3JlZi5jdXJyZW50ID0gdXBkYXRlO1xuICAgIHJldHVybiBkZXN0cm95O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXBkYXRlX3JlZi5jdXJyZW50Py4oe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhhbmRsZTogdW53cmFwX2hhbmRsZV9jYW5jZWwoaGFuZGxlKSxcbiAgICAgIGNhbmNlbDogdW53cmFwX2hhbmRsZV9jYW5jZWwoY2FuY2VsKSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBjdXN0b21fb25fZHJhZ19zdGFydCxcbiAgICAgIG9uRHJhZzogY3VzdG9tX29uX2RyYWcsXG4gICAgICBvbkRyYWdFbmQ6IGN1c3RvbV9vbl9kcmFnX2VuZFxuICAgIH0pO1xuICB9LCBbb3B0aW9uc10pO1xuICByZXR1cm4geyBpc0RyYWdnaW5nLCBkcmFnU3RhdGUgfTtcbn1cblxuZXhwb3J0IHsgdXNlRHJhZ2dhYmxlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@neodrag/react/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/component/Box.tsx":
/*!***********************************!*\
  !*** ./src/app/component/Box.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _neodrag_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neodrag/react */ \"(app-pages-browser)/./node_modules/@neodrag/react/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst Box = ()=>{\n    _s();\n    const draggable = (0,_neodrag_react__WEBPACK_IMPORTED_MODULE_1__.useDraggable)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: draggable,\n        className: \" absolute  w-40 h-12  bg-blue-100  border border-blue-500  rounded-lg  p-3  flex items-center justify-center  cursor-grab \",\n        children: \"드래그 가능!\"\n    }, void 0, false, {\n        fileName: \"/Users/gonewithmind/Documents/GitHub/creature-design/src/app/component/Box.tsx\",\n        lineNumber: 8,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Box, \"2DNc8F5Kr1ioWGgcDRP4BQEXhQo=\", false, function() {\n    return [\n        _neodrag_react__WEBPACK_IMPORTED_MODULE_1__.useDraggable\n    ];\n});\n_c = Box;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Box);\nvar _c;\n$RefreshReg$(_c, \"Box\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50L0JveC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDOEM7QUFFOUMsTUFBTUMsTUFBTTs7SUFDVixNQUFNQyxZQUFZRiw0REFBWUE7SUFFOUIscUJBQ0UsOERBQUNHO1FBQ0NDLEtBQUtGO1FBQ0xHLFdBQVU7a0JBVVg7Ozs7OztBQUlMO0dBcEJNSjs7UUFDY0Qsd0RBQVlBOzs7S0FEMUJDO0FBc0JOLGlFQUFlQSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZ29uZXdpdGhtaW5kL0RvY3VtZW50cy9HaXRIdWIvY3JlYXR1cmUtZGVzaWduL3NyYy9hcHAvY29tcG9uZW50L0JveC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VEcmFnZ2FibGUgfSBmcm9tIFwiQG5lb2RyYWcvcmVhY3RcIjtcblxuY29uc3QgQm94ID0gKCkgPT4ge1xuICBjb25zdCBkcmFnZ2FibGUgPSB1c2VEcmFnZ2FibGUoKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHJlZj17ZHJhZ2dhYmxlfVxuICAgICAgY2xhc3NOYW1lPVwiXG4gICAgICAgIGFic29sdXRlIFxuICAgICAgICB3LTQwIGgtMTIgXG4gICAgICAgIGJnLWJsdWUtMTAwIFxuICAgICAgICBib3JkZXIgYm9yZGVyLWJsdWUtNTAwIFxuICAgICAgICByb3VuZGVkLWxnIFxuICAgICAgICBwLTMgXG4gICAgICAgIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIFxuICAgICAgICBjdXJzb3ItZ3JhYlxuICAgICAgXCJcbiAgICA+XG4gICAgICDrk5zrnpjqt7gg6rCA64qlIVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQm94O1xuIl0sIm5hbWVzIjpbInVzZURyYWdnYWJsZSIsIkJveCIsImRyYWdnYWJsZSIsImRpdiIsInJlZiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/component/Box.tsx\n"));

/***/ })

});