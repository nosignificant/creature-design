"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@neodrag";
exports.ids = ["vendor-chunks/@neodrag"];
exports.modules = {

/***/ "(ssr)/./node_modules/@neodrag/react/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@neodrag/react/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDraggable: () => (/* binding */ useDraggable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\n// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar DEFAULT_DRAG_THRESHOLD = {\n  delay: 0,\n  distance: 3\n  /* DISTANCE */\n};\nfunction draggable(node, options = {}) {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = false,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    threshold = DEFAULT_DRAG_THRESHOLD,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = { x: 0, y: 0 },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let is_interacting = false;\n  let is_dragging = false;\n  let start_time = 0;\n  let meets_time_threshold = false;\n  let meets_distance_threshold = false;\n  let translate_x = 0, translate_y = 0;\n  let initial_x = 0, initial_y = 0;\n  let client_to_node_offsetX = 0, client_to_node_offsetY = 0;\n  let { x: x_offset, y: y_offset } = position ? { x: position?.x ?? 0, y: position?.y ?? 0 } : defaultPosition;\n  set_translate(x_offset, y_offset);\n  let can_move_in_x;\n  let can_move_in_y;\n  let body_original_user_select_val = \"\";\n  let computed_bounds;\n  let node_rect;\n  let drag_els;\n  let cancel_els;\n  let currently_dragged_el;\n  let is_controlled = !!position;\n  recomputeBounds = { ...DEFAULT_RECOMPUTE_BOUNDS, ...recomputeBounds };\n  threshold = { ...DEFAULT_DRAG_THRESHOLD, ...threshold ?? {} };\n  let active_pointers = /* @__PURE__ */ new Set();\n  function try_start_drag(event) {\n    if (is_interacting && !is_dragging && meets_distance_threshold && meets_time_threshold && currently_dragged_el) {\n      is_dragging = true;\n      fire_svelte_drag_start_event(event);\n      node_class_list.add(defaultClassDragging);\n      if (applyUserSelectHack) {\n        body_original_user_select_val = body_style.userSelect;\n        body_style.userSelect = \"none\";\n      }\n    }\n  }\n  function reset_state() {\n    is_dragging = false;\n    meets_time_threshold = false;\n    meets_distance_threshold = false;\n  }\n  const body_style = document.body.style;\n  const node_class_list = node.classList;\n  function set_translate(x_pos = translate_x, y_pos = translate_y) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+x_pos}px, ${+y_pos}px`;\n        return set_style(\n          node,\n          \"transform\",\n          gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`\n        );\n      }\n      return set_style(node, \"translate\", `${+x_pos}px ${+y_pos}px`);\n    }\n    const transform_called = transform({ offsetX: x_pos, offsetY: y_pos, rootNode: node });\n    if (is_string(transform_called)) {\n      set_style(node, \"transform\", transform_called);\n    }\n  }\n  function get_event_data(event) {\n    return {\n      offsetX: translate_x,\n      offsetY: translate_y,\n      rootNode: node,\n      currentNode: currently_dragged_el,\n      event\n    };\n  }\n  function call_event(eventName, fn, event) {\n    const data = get_event_data(event);\n    node.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    fn?.(data);\n  }\n  function fire_svelte_drag_start_event(event) {\n    call_event(\"neodrag:start\", onDragStart, event);\n  }\n  function fire_svelte_drag_end_event(event) {\n    call_event(\"neodrag:end\", onDragEnd, event);\n  }\n  function fire_svelte_drag_event(event) {\n    call_event(\"neodrag\", onDrag, event);\n  }\n  const listen = addEventListener;\n  const controller = new AbortController();\n  const event_options = { signal: controller.signal, capture: false };\n  set_style(node, \"touch-action\", \"none\");\n  listen(\n    \"pointerdown\",\n    (e) => {\n      if (disabled) return;\n      if (e.button === 2) return;\n      active_pointers.add(e.pointerId);\n      if (ignoreMultitouch && active_pointers.size > 1) return e.preventDefault();\n      if (recomputeBounds.dragStart) computed_bounds = compute_bound_rect(bounds, node);\n      if (is_string(handle) && is_string(cancel) && handle === cancel)\n        throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n      node_class_list.add(defaultClass);\n      drag_els = get_handle_els(handle, node);\n      cancel_els = get_cancel_elements(cancel, node);\n      can_move_in_x = /(both|x)/.test(axis);\n      can_move_in_y = /(both|y)/.test(axis);\n      if (cancel_element_contains(cancel_els, drag_els))\n        throw new Error(\n          \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n        );\n      const event_target = e.composedPath()[0];\n      if (drag_els.some((el) => el.contains(event_target) || el.shadowRoot?.contains(event_target)) && !cancel_element_contains(cancel_els, [event_target])) {\n        currently_dragged_el = drag_els.length === 1 ? node : drag_els.find((el) => el.contains(event_target));\n        is_interacting = true;\n        start_time = Date.now();\n        if (!threshold.delay) {\n          meets_time_threshold = true;\n        }\n      } else return;\n      node_rect = node.getBoundingClientRect();\n      const { clientX, clientY } = e;\n      const inverse_scale = calculate_inverse_scale();\n      if (can_move_in_x) initial_x = clientX - x_offset / inverse_scale;\n      if (can_move_in_y) initial_y = clientY - y_offset / inverse_scale;\n      if (computed_bounds) {\n        client_to_node_offsetX = clientX - node_rect.left;\n        client_to_node_offsetY = clientY - node_rect.top;\n      }\n    },\n    event_options\n  );\n  listen(\n    \"pointermove\",\n    (e) => {\n      if (!is_interacting || ignoreMultitouch && active_pointers.size > 1) return;\n      if (!is_dragging) {\n        if (!meets_time_threshold) {\n          const elapsed = Date.now() - start_time;\n          if (elapsed >= threshold.delay) {\n            meets_time_threshold = true;\n            try_start_drag(e);\n          }\n        }\n        if (!meets_distance_threshold) {\n          const delta_x = e.clientX - initial_x;\n          const delta_y = e.clientY - initial_y;\n          const distance = Math.sqrt(delta_x ** 2 + delta_y ** 2);\n          if (distance >= threshold.distance) {\n            meets_distance_threshold = true;\n            try_start_drag(e);\n          }\n        }\n        if (!is_dragging) return;\n      }\n      if (recomputeBounds.drag) computed_bounds = compute_bound_rect(bounds, node);\n      e.preventDefault();\n      node_rect = node.getBoundingClientRect();\n      let final_x = e.clientX, final_y = e.clientY;\n      const inverse_scale = calculate_inverse_scale();\n      if (computed_bounds) {\n        const virtual_client_bounds = {\n          left: computed_bounds.left + client_to_node_offsetX,\n          top: computed_bounds.top + client_to_node_offsetY,\n          right: computed_bounds.right + client_to_node_offsetX - node_rect.width,\n          bottom: computed_bounds.bottom + client_to_node_offsetY - node_rect.height\n        };\n        final_x = clamp(final_x, virtual_client_bounds.left, virtual_client_bounds.right);\n        final_y = clamp(final_y, virtual_client_bounds.top, virtual_client_bounds.bottom);\n      }\n      if (Array.isArray(grid)) {\n        let [x_snap, y_snap] = grid;\n        if (isNaN(+x_snap) || x_snap < 0)\n          throw new Error(\"1st argument of `grid` must be a valid positive number\");\n        if (isNaN(+y_snap) || y_snap < 0)\n          throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n        let delta_x = final_x - initial_x, delta_y = final_y - initial_y;\n        [delta_x, delta_y] = snap_to_grid(\n          [x_snap / inverse_scale, y_snap / inverse_scale],\n          delta_x,\n          delta_y\n        );\n        final_x = initial_x + delta_x;\n        final_y = initial_y + delta_y;\n      }\n      if (can_move_in_x) translate_x = Math.round((final_x - initial_x) * inverse_scale);\n      if (can_move_in_y) translate_y = Math.round((final_y - initial_y) * inverse_scale);\n      x_offset = translate_x;\n      y_offset = translate_y;\n      fire_svelte_drag_event(e);\n      set_translate();\n    },\n    event_options\n  );\n  listen(\n    \"pointerup\",\n    (e) => {\n      active_pointers.delete(e.pointerId);\n      if (!is_interacting) return;\n      if (is_dragging) {\n        listen(\"click\", (e2) => e2.stopPropagation(), {\n          once: true,\n          signal: controller.signal,\n          capture: true\n        });\n        if (recomputeBounds.dragEnd) computed_bounds = compute_bound_rect(bounds, node);\n        node_class_list.remove(defaultClassDragging);\n        node_class_list.add(defaultClassDragged);\n        if (applyUserSelectHack) body_style.userSelect = body_original_user_select_val;\n        fire_svelte_drag_end_event(e);\n        if (can_move_in_x) initial_x = translate_x;\n        if (can_move_in_y) initial_y = translate_y;\n      }\n      is_interacting = false;\n      reset_state();\n    },\n    event_options\n  );\n  function calculate_inverse_scale() {\n    let inverse_scale = node.offsetWidth / node_rect.width;\n    if (isNaN(inverse_scale)) inverse_scale = 1;\n    return inverse_scale;\n  }\n  return {\n    destroy: () => controller.abort(),\n    update: (options2) => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? false;\n      transform = options2.transform;\n      threshold = { ...DEFAULT_DRAG_THRESHOLD, ...options2.threshold ?? {} };\n      const dragged = node_class_list.contains(defaultClassDragged);\n      node_class_list.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      node_class_list.add(defaultClass);\n      if (dragged) node_class_list.add(defaultClassDragged);\n      if (is_controlled) {\n        x_offset = translate_x = options2.position?.x ?? translate_x;\n        y_offset = translate_y = options2.position?.y ?? translate_y;\n        set_translate();\n      }\n    }\n  };\n}\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar is_string = (val) => typeof val === \"string\";\nvar snap_to_grid = ([x_snap, y_snap], pending_x, pending_y) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pending_x, x_snap);\n  const y = calc(pending_y, y_snap);\n  return [x, y];\n};\nfunction get_handle_els(handle, node) {\n  if (!handle) return [node];\n  if (is_HTMLElement(handle)) return [handle];\n  if (Array.isArray(handle)) return handle;\n  const handle_els = node.querySelectorAll(handle);\n  if (handle_els === null)\n    throw new Error(\n      \"Selector passed for `handle` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(handle_els.values());\n}\nfunction get_cancel_elements(cancel, node) {\n  if (!cancel) return [];\n  if (is_HTMLElement(cancel)) return [cancel];\n  if (Array.isArray(cancel)) return cancel;\n  const cancel_els = node.querySelectorAll(cancel);\n  if (cancel_els === null)\n    throw new Error(\n      \"Selector passed for `cancel` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(cancel_els.values());\n}\nvar cancel_element_contains = (cancel_elements, drag_elements) => cancel_elements.some((cancelEl) => drag_elements.some((el) => cancelEl.contains(el)));\nfunction compute_bound_rect(bounds, rootNode) {\n  if (bounds === void 0) return;\n  if (is_HTMLElement(bounds)) return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n    const computed_right = window.innerWidth - right;\n    const computed_bottom = window.innerHeight - bottom;\n    return { top, right: computed_right, bottom: computed_bottom, left };\n  }\n  if (bounds === \"parent\") return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar set_style = (el, style, value) => el.style.setProperty(style, value);\nvar is_HTMLElement = (obj) => obj instanceof HTMLElement;\nfunction unwrap_handle_cancel(val) {\n  if (val == void 0 || typeof val === \"string\" || val instanceof HTMLElement) return val;\n  if (\"current\" in val) return val.current;\n  if (Array.isArray(val)) {\n    return val.map((v) => v instanceof HTMLElement ? v : v.current);\n  }\n}\nfunction useDraggable(nodeRef, options = {}) {\n  const update_ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const [isDragging, set_is_dragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [dragState, set_drag_state] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  let { onDragStart, onDrag, onDragEnd, handle, cancel } = options;\n  let new_handle = unwrap_handle_cancel(handle);\n  let new_cancel = unwrap_handle_cancel(cancel);\n  function call_event(arg, cb) {\n    set_drag_state(arg);\n    cb?.(arg);\n  }\n  function custom_on_drag_start(arg) {\n    set_is_dragging(true);\n    call_event(arg, onDragStart);\n  }\n  function custom_on_drag(arg) {\n    call_event(arg, onDrag);\n  }\n  function custom_on_drag_end(arg) {\n    set_is_dragging(false);\n    call_event(arg, onDragEnd);\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (typeof window === \"undefined\") return;\n    const node = nodeRef.current;\n    if (!node) return;\n    ({ onDragStart, onDrag, onDragEnd } = options);\n    const { update, destroy } = draggable(node, {\n      ...options,\n      handle: new_handle,\n      cancel: new_cancel,\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n    update_ref.current = update;\n    return destroy;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    update_ref.current?.({\n      ...options,\n      handle: unwrap_handle_cancel(handle),\n      cancel: unwrap_handle_cancel(cancel),\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n  }, [options]);\n  return { isDragging, dragState };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lb2RyYWcvcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBMkIsZUFBZSwyQ0FBMkM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sTUFBTSxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLHFCQUFxQixPQUFPO0FBQzlFO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTyxLQUFLLE9BQU87QUFDaEU7QUFDQSx5Q0FBeUMsZ0RBQWdEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFCQUFxQiw2Q0FBTTtBQUMzQix3Q0FBd0MsK0NBQVE7QUFDaEQsc0NBQXNDLCtDQUFRO0FBQzlDLFFBQVEsaURBQWlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQ0FBaUM7QUFDeEMsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxXQUFXO0FBQ1g7O0FBRXdCIiwic291cmNlcyI6WyIvVXNlcnMvZ29uZXdpdGhtaW5kL0RvY3VtZW50cy9HaXRIdWIvY3JlYXR1cmUtZGVzaWduL25vZGVfbW9kdWxlcy9AbmVvZHJhZy9yZWFjdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLy8gLi4vY29yZS9kaXN0L2luZGV4LmpzXG52YXIgREVGQVVMVF9SRUNPTVBVVEVfQk9VTkRTID0ge1xuICBkcmFnU3RhcnQ6IHRydWVcbn07XG52YXIgREVGQVVMVF9EUkFHX1RIUkVTSE9MRCA9IHtcbiAgZGVsYXk6IDAsXG4gIGRpc3RhbmNlOiAzXG4gIC8qIERJU1RBTkNFICovXG59O1xuZnVuY3Rpb24gZHJhZ2dhYmxlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQge1xuICAgIGJvdW5kcyxcbiAgICBheGlzID0gXCJib3RoXCIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uID0gdHJ1ZSxcbiAgICBsZWdhY3lUcmFuc2xhdGUgPSBmYWxzZSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgYXBwbHlVc2VyU2VsZWN0SGFjayA9IHRydWUsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBpZ25vcmVNdWx0aXRvdWNoID0gZmFsc2UsXG4gICAgcmVjb21wdXRlQm91bmRzID0gREVGQVVMVF9SRUNPTVBVVEVfQk9VTkRTLFxuICAgIGdyaWQsXG4gICAgdGhyZXNob2xkID0gREVGQVVMVF9EUkFHX1RIUkVTSE9MRCxcbiAgICBwb3NpdGlvbixcbiAgICBjYW5jZWwsXG4gICAgaGFuZGxlLFxuICAgIGRlZmF1bHRDbGFzcyA9IFwibmVvZHJhZ1wiLFxuICAgIGRlZmF1bHRDbGFzc0RyYWdnaW5nID0gXCJuZW9kcmFnLWRyYWdnaW5nXCIsXG4gICAgZGVmYXVsdENsYXNzRHJhZ2dlZCA9IFwibmVvZHJhZy1kcmFnZ2VkXCIsXG4gICAgZGVmYXVsdFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH0sXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25EcmFnLFxuICAgIG9uRHJhZ0VuZFxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGlzX2ludGVyYWN0aW5nID0gZmFsc2U7XG4gIGxldCBpc19kcmFnZ2luZyA9IGZhbHNlO1xuICBsZXQgc3RhcnRfdGltZSA9IDA7XG4gIGxldCBtZWV0c190aW1lX3RocmVzaG9sZCA9IGZhbHNlO1xuICBsZXQgbWVldHNfZGlzdGFuY2VfdGhyZXNob2xkID0gZmFsc2U7XG4gIGxldCB0cmFuc2xhdGVfeCA9IDAsIHRyYW5zbGF0ZV95ID0gMDtcbiAgbGV0IGluaXRpYWxfeCA9IDAsIGluaXRpYWxfeSA9IDA7XG4gIGxldCBjbGllbnRfdG9fbm9kZV9vZmZzZXRYID0gMCwgY2xpZW50X3RvX25vZGVfb2Zmc2V0WSA9IDA7XG4gIGxldCB7IHg6IHhfb2Zmc2V0LCB5OiB5X29mZnNldCB9ID0gcG9zaXRpb24gPyB7IHg6IHBvc2l0aW9uPy54ID8/IDAsIHk6IHBvc2l0aW9uPy55ID8/IDAgfSA6IGRlZmF1bHRQb3NpdGlvbjtcbiAgc2V0X3RyYW5zbGF0ZSh4X29mZnNldCwgeV9vZmZzZXQpO1xuICBsZXQgY2FuX21vdmVfaW5feDtcbiAgbGV0IGNhbl9tb3ZlX2luX3k7XG4gIGxldCBib2R5X29yaWdpbmFsX3VzZXJfc2VsZWN0X3ZhbCA9IFwiXCI7XG4gIGxldCBjb21wdXRlZF9ib3VuZHM7XG4gIGxldCBub2RlX3JlY3Q7XG4gIGxldCBkcmFnX2VscztcbiAgbGV0IGNhbmNlbF9lbHM7XG4gIGxldCBjdXJyZW50bHlfZHJhZ2dlZF9lbDtcbiAgbGV0IGlzX2NvbnRyb2xsZWQgPSAhIXBvc2l0aW9uO1xuICByZWNvbXB1dGVCb3VuZHMgPSB7IC4uLkRFRkFVTFRfUkVDT01QVVRFX0JPVU5EUywgLi4ucmVjb21wdXRlQm91bmRzIH07XG4gIHRocmVzaG9sZCA9IHsgLi4uREVGQVVMVF9EUkFHX1RIUkVTSE9MRCwgLi4udGhyZXNob2xkID8/IHt9IH07XG4gIGxldCBhY3RpdmVfcG9pbnRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiB0cnlfc3RhcnRfZHJhZyhldmVudCkge1xuICAgIGlmIChpc19pbnRlcmFjdGluZyAmJiAhaXNfZHJhZ2dpbmcgJiYgbWVldHNfZGlzdGFuY2VfdGhyZXNob2xkICYmIG1lZXRzX3RpbWVfdGhyZXNob2xkICYmIGN1cnJlbnRseV9kcmFnZ2VkX2VsKSB7XG4gICAgICBpc19kcmFnZ2luZyA9IHRydWU7XG4gICAgICBmaXJlX3N2ZWx0ZV9kcmFnX3N0YXJ0X2V2ZW50KGV2ZW50KTtcbiAgICAgIG5vZGVfY2xhc3NfbGlzdC5hZGQoZGVmYXVsdENsYXNzRHJhZ2dpbmcpO1xuICAgICAgaWYgKGFwcGx5VXNlclNlbGVjdEhhY2spIHtcbiAgICAgICAgYm9keV9vcmlnaW5hbF91c2VyX3NlbGVjdF92YWwgPSBib2R5X3N0eWxlLnVzZXJTZWxlY3Q7XG4gICAgICAgIGJvZHlfc3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXNldF9zdGF0ZSgpIHtcbiAgICBpc19kcmFnZ2luZyA9IGZhbHNlO1xuICAgIG1lZXRzX3RpbWVfdGhyZXNob2xkID0gZmFsc2U7XG4gICAgbWVldHNfZGlzdGFuY2VfdGhyZXNob2xkID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keV9zdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gIGNvbnN0IG5vZGVfY2xhc3NfbGlzdCA9IG5vZGUuY2xhc3NMaXN0O1xuICBmdW5jdGlvbiBzZXRfdHJhbnNsYXRlKHhfcG9zID0gdHJhbnNsYXRlX3gsIHlfcG9zID0gdHJhbnNsYXRlX3kpIHtcbiAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgaWYgKGxlZ2FjeVRyYW5zbGF0ZSkge1xuICAgICAgICBsZXQgY29tbW9uID0gYCR7K3hfcG9zfXB4LCAkeyt5X3Bvc31weGA7XG4gICAgICAgIHJldHVybiBzZXRfc3R5bGUoXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgIGdwdUFjY2VsZXJhdGlvbiA/IGB0cmFuc2xhdGUzZCgke2NvbW1vbn0sIDApYCA6IGB0cmFuc2xhdGUoJHtjb21tb259KWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRfc3R5bGUobm9kZSwgXCJ0cmFuc2xhdGVcIiwgYCR7K3hfcG9zfXB4ICR7K3lfcG9zfXB4YCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybV9jYWxsZWQgPSB0cmFuc2Zvcm0oeyBvZmZzZXRYOiB4X3Bvcywgb2Zmc2V0WTogeV9wb3MsIHJvb3ROb2RlOiBub2RlIH0pO1xuICAgIGlmIChpc19zdHJpbmcodHJhbnNmb3JtX2NhbGxlZCkpIHtcbiAgICAgIHNldF9zdHlsZShub2RlLCBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm1fY2FsbGVkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0X2V2ZW50X2RhdGEoZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WDogdHJhbnNsYXRlX3gsXG4gICAgICBvZmZzZXRZOiB0cmFuc2xhdGVfeSxcbiAgICAgIHJvb3ROb2RlOiBub2RlLFxuICAgICAgY3VycmVudE5vZGU6IGN1cnJlbnRseV9kcmFnZ2VkX2VsLFxuICAgICAgZXZlbnRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhbGxfZXZlbnQoZXZlbnROYW1lLCBmbiwgZXZlbnQpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0X2V2ZW50X2RhdGEoZXZlbnQpO1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbDogZGF0YSB9KSk7XG4gICAgZm4/LihkYXRhKTtcbiAgfVxuICBmdW5jdGlvbiBmaXJlX3N2ZWx0ZV9kcmFnX3N0YXJ0X2V2ZW50KGV2ZW50KSB7XG4gICAgY2FsbF9ldmVudChcIm5lb2RyYWc6c3RhcnRcIiwgb25EcmFnU3RhcnQsIGV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBmaXJlX3N2ZWx0ZV9kcmFnX2VuZF9ldmVudChldmVudCkge1xuICAgIGNhbGxfZXZlbnQoXCJuZW9kcmFnOmVuZFwiLCBvbkRyYWdFbmQsIGV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBmaXJlX3N2ZWx0ZV9kcmFnX2V2ZW50KGV2ZW50KSB7XG4gICAgY2FsbF9ldmVudChcIm5lb2RyYWdcIiwgb25EcmFnLCBldmVudCk7XG4gIH1cbiAgY29uc3QgbGlzdGVuID0gYWRkRXZlbnRMaXN0ZW5lcjtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3QgZXZlbnRfb3B0aW9ucyA9IHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCwgY2FwdHVyZTogZmFsc2UgfTtcbiAgc2V0X3N0eWxlKG5vZGUsIFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKTtcbiAgbGlzdGVuKFxuICAgIFwicG9pbnRlcmRvd25cIixcbiAgICAoZSkgPT4ge1xuICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgICBpZiAoZS5idXR0b24gPT09IDIpIHJldHVybjtcbiAgICAgIGFjdGl2ZV9wb2ludGVycy5hZGQoZS5wb2ludGVySWQpO1xuICAgICAgaWYgKGlnbm9yZU11bHRpdG91Y2ggJiYgYWN0aXZlX3BvaW50ZXJzLnNpemUgPiAxKSByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHJlY29tcHV0ZUJvdW5kcy5kcmFnU3RhcnQpIGNvbXB1dGVkX2JvdW5kcyA9IGNvbXB1dGVfYm91bmRfcmVjdChib3VuZHMsIG5vZGUpO1xuICAgICAgaWYgKGlzX3N0cmluZyhoYW5kbGUpICYmIGlzX3N0cmluZyhjYW5jZWwpICYmIGhhbmRsZSA9PT0gY2FuY2VsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaGFuZGxlYCBzZWxlY3RvciBjYW4ndCBiZSBzYW1lIGFzIGBjYW5jZWxgIHNlbGVjdG9yXCIpO1xuICAgICAgbm9kZV9jbGFzc19saXN0LmFkZChkZWZhdWx0Q2xhc3MpO1xuICAgICAgZHJhZ19lbHMgPSBnZXRfaGFuZGxlX2VscyhoYW5kbGUsIG5vZGUpO1xuICAgICAgY2FuY2VsX2VscyA9IGdldF9jYW5jZWxfZWxlbWVudHMoY2FuY2VsLCBub2RlKTtcbiAgICAgIGNhbl9tb3ZlX2luX3ggPSAvKGJvdGh8eCkvLnRlc3QoYXhpcyk7XG4gICAgICBjYW5fbW92ZV9pbl95ID0gLyhib3RofHkpLy50ZXN0KGF4aXMpO1xuICAgICAgaWYgKGNhbmNlbF9lbGVtZW50X2NvbnRhaW5zKGNhbmNlbF9lbHMsIGRyYWdfZWxzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiRWxlbWVudCBiZWluZyBkcmFnZ2VkIGNhbid0IGJlIGEgY2hpbGQgb2YgdGhlIGVsZW1lbnQgb24gd2hpY2ggYGNhbmNlbGAgaXMgYXBwbGllZFwiXG4gICAgICAgICk7XG4gICAgICBjb25zdCBldmVudF90YXJnZXQgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgaWYgKGRyYWdfZWxzLnNvbWUoKGVsKSA9PiBlbC5jb250YWlucyhldmVudF90YXJnZXQpIHx8IGVsLnNoYWRvd1Jvb3Q/LmNvbnRhaW5zKGV2ZW50X3RhcmdldCkpICYmICFjYW5jZWxfZWxlbWVudF9jb250YWlucyhjYW5jZWxfZWxzLCBbZXZlbnRfdGFyZ2V0XSkpIHtcbiAgICAgICAgY3VycmVudGx5X2RyYWdnZWRfZWwgPSBkcmFnX2Vscy5sZW5ndGggPT09IDEgPyBub2RlIDogZHJhZ19lbHMuZmluZCgoZWwpID0+IGVsLmNvbnRhaW5zKGV2ZW50X3RhcmdldCkpO1xuICAgICAgICBpc19pbnRlcmFjdGluZyA9IHRydWU7XG4gICAgICAgIHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoIXRocmVzaG9sZC5kZWxheSkge1xuICAgICAgICAgIG1lZXRzX3RpbWVfdGhyZXNob2xkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHJldHVybjtcbiAgICAgIG5vZGVfcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICBjb25zdCBpbnZlcnNlX3NjYWxlID0gY2FsY3VsYXRlX2ludmVyc2Vfc2NhbGUoKTtcbiAgICAgIGlmIChjYW5fbW92ZV9pbl94KSBpbml0aWFsX3ggPSBjbGllbnRYIC0geF9vZmZzZXQgLyBpbnZlcnNlX3NjYWxlO1xuICAgICAgaWYgKGNhbl9tb3ZlX2luX3kpIGluaXRpYWxfeSA9IGNsaWVudFkgLSB5X29mZnNldCAvIGludmVyc2Vfc2NhbGU7XG4gICAgICBpZiAoY29tcHV0ZWRfYm91bmRzKSB7XG4gICAgICAgIGNsaWVudF90b19ub2RlX29mZnNldFggPSBjbGllbnRYIC0gbm9kZV9yZWN0LmxlZnQ7XG4gICAgICAgIGNsaWVudF90b19ub2RlX29mZnNldFkgPSBjbGllbnRZIC0gbm9kZV9yZWN0LnRvcDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50X29wdGlvbnNcbiAgKTtcbiAgbGlzdGVuKFxuICAgIFwicG9pbnRlcm1vdmVcIixcbiAgICAoZSkgPT4ge1xuICAgICAgaWYgKCFpc19pbnRlcmFjdGluZyB8fCBpZ25vcmVNdWx0aXRvdWNoICYmIGFjdGl2ZV9wb2ludGVycy5zaXplID4gMSkgcmV0dXJuO1xuICAgICAgaWYgKCFpc19kcmFnZ2luZykge1xuICAgICAgICBpZiAoIW1lZXRzX3RpbWVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBzdGFydF90aW1lO1xuICAgICAgICAgIGlmIChlbGFwc2VkID49IHRocmVzaG9sZC5kZWxheSkge1xuICAgICAgICAgICAgbWVldHNfdGltZV90aHJlc2hvbGQgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5X3N0YXJ0X2RyYWcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWVldHNfZGlzdGFuY2VfdGhyZXNob2xkKSB7XG4gICAgICAgICAgY29uc3QgZGVsdGFfeCA9IGUuY2xpZW50WCAtIGluaXRpYWxfeDtcbiAgICAgICAgICBjb25zdCBkZWx0YV95ID0gZS5jbGllbnRZIC0gaW5pdGlhbF95O1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRlbHRhX3ggKiogMiArIGRlbHRhX3kgKiogMik7XG4gICAgICAgICAgaWYgKGRpc3RhbmNlID49IHRocmVzaG9sZC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgbWVldHNfZGlzdGFuY2VfdGhyZXNob2xkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeV9zdGFydF9kcmFnKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzX2RyYWdnaW5nKSByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVjb21wdXRlQm91bmRzLmRyYWcpIGNvbXB1dGVkX2JvdW5kcyA9IGNvbXB1dGVfYm91bmRfcmVjdChib3VuZHMsIG5vZGUpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbm9kZV9yZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxldCBmaW5hbF94ID0gZS5jbGllbnRYLCBmaW5hbF95ID0gZS5jbGllbnRZO1xuICAgICAgY29uc3QgaW52ZXJzZV9zY2FsZSA9IGNhbGN1bGF0ZV9pbnZlcnNlX3NjYWxlKCk7XG4gICAgICBpZiAoY29tcHV0ZWRfYm91bmRzKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxfY2xpZW50X2JvdW5kcyA9IHtcbiAgICAgICAgICBsZWZ0OiBjb21wdXRlZF9ib3VuZHMubGVmdCArIGNsaWVudF90b19ub2RlX29mZnNldFgsXG4gICAgICAgICAgdG9wOiBjb21wdXRlZF9ib3VuZHMudG9wICsgY2xpZW50X3RvX25vZGVfb2Zmc2V0WSxcbiAgICAgICAgICByaWdodDogY29tcHV0ZWRfYm91bmRzLnJpZ2h0ICsgY2xpZW50X3RvX25vZGVfb2Zmc2V0WCAtIG5vZGVfcmVjdC53aWR0aCxcbiAgICAgICAgICBib3R0b206IGNvbXB1dGVkX2JvdW5kcy5ib3R0b20gKyBjbGllbnRfdG9fbm9kZV9vZmZzZXRZIC0gbm9kZV9yZWN0LmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBmaW5hbF94ID0gY2xhbXAoZmluYWxfeCwgdmlydHVhbF9jbGllbnRfYm91bmRzLmxlZnQsIHZpcnR1YWxfY2xpZW50X2JvdW5kcy5yaWdodCk7XG4gICAgICAgIGZpbmFsX3kgPSBjbGFtcChmaW5hbF95LCB2aXJ0dWFsX2NsaWVudF9ib3VuZHMudG9wLCB2aXJ0dWFsX2NsaWVudF9ib3VuZHMuYm90dG9tKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyaWQpKSB7XG4gICAgICAgIGxldCBbeF9zbmFwLCB5X3NuYXBdID0gZ3JpZDtcbiAgICAgICAgaWYgKGlzTmFOKCt4X3NuYXApIHx8IHhfc25hcCA8IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMXN0IGFyZ3VtZW50IG9mIGBncmlkYCBtdXN0IGJlIGEgdmFsaWQgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICBpZiAoaXNOYU4oK3lfc25hcCkgfHwgeV9zbmFwIDwgMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIybmQgYXJndW1lbnQgb2YgYGdyaWRgIG11c3QgYmUgYSB2YWxpZCBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIGxldCBkZWx0YV94ID0gZmluYWxfeCAtIGluaXRpYWxfeCwgZGVsdGFfeSA9IGZpbmFsX3kgLSBpbml0aWFsX3k7XG4gICAgICAgIFtkZWx0YV94LCBkZWx0YV95XSA9IHNuYXBfdG9fZ3JpZChcbiAgICAgICAgICBbeF9zbmFwIC8gaW52ZXJzZV9zY2FsZSwgeV9zbmFwIC8gaW52ZXJzZV9zY2FsZV0sXG4gICAgICAgICAgZGVsdGFfeCxcbiAgICAgICAgICBkZWx0YV95XG4gICAgICAgICk7XG4gICAgICAgIGZpbmFsX3ggPSBpbml0aWFsX3ggKyBkZWx0YV94O1xuICAgICAgICBmaW5hbF95ID0gaW5pdGlhbF95ICsgZGVsdGFfeTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5fbW92ZV9pbl94KSB0cmFuc2xhdGVfeCA9IE1hdGgucm91bmQoKGZpbmFsX3ggLSBpbml0aWFsX3gpICogaW52ZXJzZV9zY2FsZSk7XG4gICAgICBpZiAoY2FuX21vdmVfaW5feSkgdHJhbnNsYXRlX3kgPSBNYXRoLnJvdW5kKChmaW5hbF95IC0gaW5pdGlhbF95KSAqIGludmVyc2Vfc2NhbGUpO1xuICAgICAgeF9vZmZzZXQgPSB0cmFuc2xhdGVfeDtcbiAgICAgIHlfb2Zmc2V0ID0gdHJhbnNsYXRlX3k7XG4gICAgICBmaXJlX3N2ZWx0ZV9kcmFnX2V2ZW50KGUpO1xuICAgICAgc2V0X3RyYW5zbGF0ZSgpO1xuICAgIH0sXG4gICAgZXZlbnRfb3B0aW9uc1xuICApO1xuICBsaXN0ZW4oXG4gICAgXCJwb2ludGVydXBcIixcbiAgICAoZSkgPT4ge1xuICAgICAgYWN0aXZlX3BvaW50ZXJzLmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICBpZiAoIWlzX2ludGVyYWN0aW5nKSByZXR1cm47XG4gICAgICBpZiAoaXNfZHJhZ2dpbmcpIHtcbiAgICAgICAgbGlzdGVuKFwiY2xpY2tcIiwgKGUyKSA9PiBlMi5zdG9wUHJvcGFnYXRpb24oKSwge1xuICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVjb21wdXRlQm91bmRzLmRyYWdFbmQpIGNvbXB1dGVkX2JvdW5kcyA9IGNvbXB1dGVfYm91bmRfcmVjdChib3VuZHMsIG5vZGUpO1xuICAgICAgICBub2RlX2NsYXNzX2xpc3QucmVtb3ZlKGRlZmF1bHRDbGFzc0RyYWdnaW5nKTtcbiAgICAgICAgbm9kZV9jbGFzc19saXN0LmFkZChkZWZhdWx0Q2xhc3NEcmFnZ2VkKTtcbiAgICAgICAgaWYgKGFwcGx5VXNlclNlbGVjdEhhY2spIGJvZHlfc3R5bGUudXNlclNlbGVjdCA9IGJvZHlfb3JpZ2luYWxfdXNlcl9zZWxlY3RfdmFsO1xuICAgICAgICBmaXJlX3N2ZWx0ZV9kcmFnX2VuZF9ldmVudChlKTtcbiAgICAgICAgaWYgKGNhbl9tb3ZlX2luX3gpIGluaXRpYWxfeCA9IHRyYW5zbGF0ZV94O1xuICAgICAgICBpZiAoY2FuX21vdmVfaW5feSkgaW5pdGlhbF95ID0gdHJhbnNsYXRlX3k7XG4gICAgICB9XG4gICAgICBpc19pbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgICAgcmVzZXRfc3RhdGUoKTtcbiAgICB9LFxuICAgIGV2ZW50X29wdGlvbnNcbiAgKTtcbiAgZnVuY3Rpb24gY2FsY3VsYXRlX2ludmVyc2Vfc2NhbGUoKSB7XG4gICAgbGV0IGludmVyc2Vfc2NhbGUgPSBub2RlLm9mZnNldFdpZHRoIC8gbm9kZV9yZWN0LndpZHRoO1xuICAgIGlmIChpc05hTihpbnZlcnNlX3NjYWxlKSkgaW52ZXJzZV9zY2FsZSA9IDE7XG4gICAgcmV0dXJuIGludmVyc2Vfc2NhbGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgdXBkYXRlOiAob3B0aW9uczIpID0+IHtcbiAgICAgIGF4aXMgPSBvcHRpb25zMi5heGlzIHx8IFwiYm90aFwiO1xuICAgICAgZGlzYWJsZWQgPSBvcHRpb25zMi5kaXNhYmxlZCA/PyBmYWxzZTtcbiAgICAgIGlnbm9yZU11bHRpdG91Y2ggPSBvcHRpb25zMi5pZ25vcmVNdWx0aXRvdWNoID8/IGZhbHNlO1xuICAgICAgaGFuZGxlID0gb3B0aW9uczIuaGFuZGxlO1xuICAgICAgYm91bmRzID0gb3B0aW9uczIuYm91bmRzO1xuICAgICAgcmVjb21wdXRlQm91bmRzID0gb3B0aW9uczIucmVjb21wdXRlQm91bmRzID8/IERFRkFVTFRfUkVDT01QVVRFX0JPVU5EUztcbiAgICAgIGNhbmNlbCA9IG9wdGlvbnMyLmNhbmNlbDtcbiAgICAgIGFwcGx5VXNlclNlbGVjdEhhY2sgPSBvcHRpb25zMi5hcHBseVVzZXJTZWxlY3RIYWNrID8/IHRydWU7XG4gICAgICBncmlkID0gb3B0aW9uczIuZ3JpZDtcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IG9wdGlvbnMyLmdwdUFjY2VsZXJhdGlvbiA/PyB0cnVlO1xuICAgICAgbGVnYWN5VHJhbnNsYXRlID0gb3B0aW9uczIubGVnYWN5VHJhbnNsYXRlID8/IGZhbHNlO1xuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uczIudHJhbnNmb3JtO1xuICAgICAgdGhyZXNob2xkID0geyAuLi5ERUZBVUxUX0RSQUdfVEhSRVNIT0xELCAuLi5vcHRpb25zMi50aHJlc2hvbGQgPz8ge30gfTtcbiAgICAgIGNvbnN0IGRyYWdnZWQgPSBub2RlX2NsYXNzX2xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzRHJhZ2dlZCk7XG4gICAgICBub2RlX2NsYXNzX2xpc3QucmVtb3ZlKGRlZmF1bHRDbGFzcywgZGVmYXVsdENsYXNzRHJhZ2dlZCk7XG4gICAgICBkZWZhdWx0Q2xhc3MgPSBvcHRpb25zMi5kZWZhdWx0Q2xhc3MgPz8gXCJuZW9kcmFnXCI7XG4gICAgICBkZWZhdWx0Q2xhc3NEcmFnZ2luZyA9IG9wdGlvbnMyLmRlZmF1bHRDbGFzc0RyYWdnaW5nID8/IFwibmVvZHJhZy1kcmFnZ2luZ1wiO1xuICAgICAgZGVmYXVsdENsYXNzRHJhZ2dlZCA9IG9wdGlvbnMyLmRlZmF1bHRDbGFzc0RyYWdnZWQgPz8gXCJuZW9kcmFnLWRyYWdnZWRcIjtcbiAgICAgIG5vZGVfY2xhc3NfbGlzdC5hZGQoZGVmYXVsdENsYXNzKTtcbiAgICAgIGlmIChkcmFnZ2VkKSBub2RlX2NsYXNzX2xpc3QuYWRkKGRlZmF1bHRDbGFzc0RyYWdnZWQpO1xuICAgICAgaWYgKGlzX2NvbnRyb2xsZWQpIHtcbiAgICAgICAgeF9vZmZzZXQgPSB0cmFuc2xhdGVfeCA9IG9wdGlvbnMyLnBvc2l0aW9uPy54ID8/IHRyYW5zbGF0ZV94O1xuICAgICAgICB5X29mZnNldCA9IHRyYW5zbGF0ZV95ID0gb3B0aW9uczIucG9zaXRpb24/LnkgPz8gdHJhbnNsYXRlX3k7XG4gICAgICAgIHNldF90cmFuc2xhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgY2xhbXAgPSAodmFsLCBtaW4sIG1heCkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xudmFyIGlzX3N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG52YXIgc25hcF90b19ncmlkID0gKFt4X3NuYXAsIHlfc25hcF0sIHBlbmRpbmdfeCwgcGVuZGluZ195KSA9PiB7XG4gIGNvbnN0IGNhbGMgPSAodmFsLCBzbmFwKSA9PiBzbmFwID09PSAwID8gMCA6IE1hdGguY2VpbCh2YWwgLyBzbmFwKSAqIHNuYXA7XG4gIGNvbnN0IHggPSBjYWxjKHBlbmRpbmdfeCwgeF9zbmFwKTtcbiAgY29uc3QgeSA9IGNhbGMocGVuZGluZ195LCB5X3NuYXApO1xuICByZXR1cm4gW3gsIHldO1xufTtcbmZ1bmN0aW9uIGdldF9oYW5kbGVfZWxzKGhhbmRsZSwgbm9kZSkge1xuICBpZiAoIWhhbmRsZSkgcmV0dXJuIFtub2RlXTtcbiAgaWYgKGlzX0hUTUxFbGVtZW50KGhhbmRsZSkpIHJldHVybiBbaGFuZGxlXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlKSkgcmV0dXJuIGhhbmRsZTtcbiAgY29uc3QgaGFuZGxlX2VscyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChoYW5kbGUpO1xuICBpZiAoaGFuZGxlX2VscyA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlNlbGVjdG9yIHBhc3NlZCBmb3IgYGhhbmRsZWAgb3B0aW9uIHNob3VsZCBiZSBjaGlsZCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgYWN0aW9uIGlzIGFwcGxpZWRcIlxuICAgICk7XG4gIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZV9lbHMudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gZ2V0X2NhbmNlbF9lbGVtZW50cyhjYW5jZWwsIG5vZGUpIHtcbiAgaWYgKCFjYW5jZWwpIHJldHVybiBbXTtcbiAgaWYgKGlzX0hUTUxFbGVtZW50KGNhbmNlbCkpIHJldHVybiBbY2FuY2VsXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2FuY2VsKSkgcmV0dXJuIGNhbmNlbDtcbiAgY29uc3QgY2FuY2VsX2VscyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChjYW5jZWwpO1xuICBpZiAoY2FuY2VsX2VscyA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlNlbGVjdG9yIHBhc3NlZCBmb3IgYGNhbmNlbGAgb3B0aW9uIHNob3VsZCBiZSBjaGlsZCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgYWN0aW9uIGlzIGFwcGxpZWRcIlxuICAgICk7XG4gIHJldHVybiBBcnJheS5mcm9tKGNhbmNlbF9lbHMudmFsdWVzKCkpO1xufVxudmFyIGNhbmNlbF9lbGVtZW50X2NvbnRhaW5zID0gKGNhbmNlbF9lbGVtZW50cywgZHJhZ19lbGVtZW50cykgPT4gY2FuY2VsX2VsZW1lbnRzLnNvbWUoKGNhbmNlbEVsKSA9PiBkcmFnX2VsZW1lbnRzLnNvbWUoKGVsKSA9PiBjYW5jZWxFbC5jb250YWlucyhlbCkpKTtcbmZ1bmN0aW9uIGNvbXB1dGVfYm91bmRfcmVjdChib3VuZHMsIHJvb3ROb2RlKSB7XG4gIGlmIChib3VuZHMgPT09IHZvaWQgMCkgcmV0dXJuO1xuICBpZiAoaXNfSFRNTEVsZW1lbnQoYm91bmRzKSkgcmV0dXJuIGJvdW5kcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgaWYgKHR5cGVvZiBib3VuZHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCB7IHRvcCA9IDAsIGxlZnQgPSAwLCByaWdodCA9IDAsIGJvdHRvbSA9IDAgfSA9IGJvdW5kcztcbiAgICBjb25zdCBjb21wdXRlZF9yaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gcmlnaHQ7XG4gICAgY29uc3QgY29tcHV0ZWRfYm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0IC0gYm90dG9tO1xuICAgIHJldHVybiB7IHRvcCwgcmlnaHQ6IGNvbXB1dGVkX3JpZ2h0LCBib3R0b206IGNvbXB1dGVkX2JvdHRvbSwgbGVmdCB9O1xuICB9XG4gIGlmIChib3VuZHMgPT09IFwicGFyZW50XCIpIHJldHVybiByb290Tm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuICBpZiAobm9kZSA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2VsZWN0b3IgcHJvdmlkZWQgZm9yIGJvdW5kIGRvZXNuJ3QgZXhpc3RzIGluIHRoZSBkb2N1bWVudC5cIik7XG4gIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxudmFyIHNldF9zdHlsZSA9IChlbCwgc3R5bGUsIHZhbHVlKSA9PiBlbC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZSwgdmFsdWUpO1xudmFyIGlzX0hUTUxFbGVtZW50ID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG5mdW5jdGlvbiB1bndyYXBfaGFuZGxlX2NhbmNlbCh2YWwpIHtcbiAgaWYgKHZhbCA9PSB2b2lkIDAgfHwgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB2YWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgcmV0dXJuIHZhbDtcbiAgaWYgKFwiY3VycmVudFwiIGluIHZhbCkgcmV0dXJuIHZhbC5jdXJyZW50O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5tYXAoKHYpID0+IHYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IHYgOiB2LmN1cnJlbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VEcmFnZ2FibGUobm9kZVJlZiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHVwZGF0ZV9yZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldF9pc19kcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkcmFnU3RhdGUsIHNldF9kcmFnX3N0YXRlXSA9IHVzZVN0YXRlKCk7XG4gIGxldCB7IG9uRHJhZ1N0YXJ0LCBvbkRyYWcsIG9uRHJhZ0VuZCwgaGFuZGxlLCBjYW5jZWwgfSA9IG9wdGlvbnM7XG4gIGxldCBuZXdfaGFuZGxlID0gdW53cmFwX2hhbmRsZV9jYW5jZWwoaGFuZGxlKTtcbiAgbGV0IG5ld19jYW5jZWwgPSB1bndyYXBfaGFuZGxlX2NhbmNlbChjYW5jZWwpO1xuICBmdW5jdGlvbiBjYWxsX2V2ZW50KGFyZywgY2IpIHtcbiAgICBzZXRfZHJhZ19zdGF0ZShhcmcpO1xuICAgIGNiPy4oYXJnKTtcbiAgfVxuICBmdW5jdGlvbiBjdXN0b21fb25fZHJhZ19zdGFydChhcmcpIHtcbiAgICBzZXRfaXNfZHJhZ2dpbmcodHJ1ZSk7XG4gICAgY2FsbF9ldmVudChhcmcsIG9uRHJhZ1N0YXJ0KTtcbiAgfVxuICBmdW5jdGlvbiBjdXN0b21fb25fZHJhZyhhcmcpIHtcbiAgICBjYWxsX2V2ZW50KGFyZywgb25EcmFnKTtcbiAgfVxuICBmdW5jdGlvbiBjdXN0b21fb25fZHJhZ19lbmQoYXJnKSB7XG4gICAgc2V0X2lzX2RyYWdnaW5nKGZhbHNlKTtcbiAgICBjYWxsX2V2ZW50KGFyZywgb25EcmFnRW5kKTtcbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVSZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAoeyBvbkRyYWdTdGFydCwgb25EcmFnLCBvbkRyYWdFbmQgfSA9IG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgdXBkYXRlLCBkZXN0cm95IH0gPSBkcmFnZ2FibGUobm9kZSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhhbmRsZTogbmV3X2hhbmRsZSxcbiAgICAgIGNhbmNlbDogbmV3X2NhbmNlbCxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBjdXN0b21fb25fZHJhZ19zdGFydCxcbiAgICAgIG9uRHJhZzogY3VzdG9tX29uX2RyYWcsXG4gICAgICBvbkRyYWdFbmQ6IGN1c3RvbV9vbl9kcmFnX2VuZFxuICAgIH0pO1xuICAgIHVwZGF0ZV9yZWYuY3VycmVudCA9IHVwZGF0ZTtcbiAgICByZXR1cm4gZGVzdHJveTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVwZGF0ZV9yZWYuY3VycmVudD8uKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoYW5kbGU6IHVud3JhcF9oYW5kbGVfY2FuY2VsKGhhbmRsZSksXG4gICAgICBjYW5jZWw6IHVud3JhcF9oYW5kbGVfY2FuY2VsKGNhbmNlbCksXG4gICAgICBvbkRyYWdTdGFydDogY3VzdG9tX29uX2RyYWdfc3RhcnQsXG4gICAgICBvbkRyYWc6IGN1c3RvbV9vbl9kcmFnLFxuICAgICAgb25EcmFnRW5kOiBjdXN0b21fb25fZHJhZ19lbmRcbiAgICB9KTtcbiAgfSwgW29wdGlvbnNdKTtcbiAgcmV0dXJuIHsgaXNEcmFnZ2luZywgZHJhZ1N0YXRlIH07XG59XG5cbmV4cG9ydCB7IHVzZURyYWdnYWJsZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@neodrag/react/dist/index.js\n");

/***/ })

};
;